<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.RdFramework</name>
    </assembly>
    <members>
        <member name="T:JetBrains.Rd.Base.IPerContextMap`2">
             <summary>
             <para>
             A collection that automatically maps values to keys from RdContext's value set.
             Key-value pairs in this map are automatically managed based on possible values of RdContext.
             </para>
            
             <para>
             As context value sets are protocol-specific, this map will behave differently depending on whether or not it's bound to a <see cref="T:JetBrains.Rd.IProtocol"/>.
             An unbound map will automatically create mappings for all context values it's accessed with. When a map is bound later, all values not present in protocol value set will be silently dropped.
             </para>
             </summary>
             <seealso cref="M:JetBrains.Rd.Impl.ProtocolContexts.GetValueSet``1(JetBrains.Rd.RdContext{``0})"/>
        </member>
        <member name="P:JetBrains.Rd.Base.IPerContextMap`2.Context">
            <summary>
            The context that is used by this map. Must be heavy.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Base.IPerContextMap`2.GetForCurrentContext">
            <summary>
            Gets the value associated with current context value, equivalent to this[Key.Value].
            If the context doesn't have a value set, or key's protocol value set does not contain the current context value, this will throw an exception
            </summary>
        </member>
        <member name="P:JetBrains.Rd.Base.IPerContextMap`2.Item(`0)">
            <summary>
            Gets the value associated with specified context value, or throws an exception if none is associated.
            When this map is not bound, this will automatically create a new mapping instead of throwing
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Base.IPerContextMap`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with specified context value and returns true, or returns false if none is associated
            When this map is not bound, this will automatically create a new mapping instead of returning false
            </summary>
        </member>
        <member name="T:JetBrains.Rd.IInternRoot`1">
            <summary>
            Interns values sent over protocol
            </summary>
        </member>
        <member name="M:JetBrains.Rd.IInternRoot`1.TryGetInterned(`0)">
            <summary>
            Tries to get an ID for a value. Doesn't intern it if it's not interned.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.IInternRoot`1.Intern(`0)">
            <summary>
            Interns a value and returns an ID for it. May return invalid ID in case of multithreaded contention.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.IInternRoot`1.UnIntern``1(JetBrains.Rd.InternId)">
            <summary>
            Gets a value from an interned ID. Throws an exception if the ID doesn't correspond to a value
            </summary>
        </member>
        <member name="M:JetBrains.Rd.IInternRoot`1.TryUnIntern``1(JetBrains.Rd.InternId,``0@)">
            <summary>
            Gets a value from an interned ID. Returns true if successful, false otherwise
            </summary>
        </member>
        <member name="M:JetBrains.Rd.IInternRoot`1.Remove(`0)">
            <summary>
            Removes an interned value. Any future attempts to un-intern IDs previously associated with this value will fail.
            Not thread-safe. It's up to user to ensure that the value being removed is not being used in messages written on background threads.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.InternId">
            <summary>
            An ID representing an interned value
            </summary>
        </member>
        <member name="P:JetBrains.Rd.InternId.IsValid">
            <summary>
            True if this ID represents an actual interned value. False indicates a failed interning operation or unset value
            </summary>
        </member>
        <member name="P:JetBrains.Rd.InternId.IsLocal">
            <summary>
            True if this ID represents a value interned by local InternRoot 
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.Protocol.ProtocolInternRootRdId">
            <summary>
            Should match textual RdId of protocol intern root in Kotlin/js/cpp counterpart
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.Protocol.ProtocolInternScopeStringId">
            <summary>
            Should match whatever is in rd-gen for ProtocolInternScope
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.ProtocolContexts">
            <summary>
            This class handles RdContext on protocol level. It tracks existing contexts and allows access to their value sets (when present)
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Impl.ProtocolContexts.GetValueSet``1(JetBrains.Rd.RdContext{``0})">
            <summary>
            Get a value set for a given key. The values are local relative to transform
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Impl.ProtocolContexts.RegisterContext``1(JetBrains.Rd.RdContext{``0})">
            <summary>
            Registers a context to be used with this context handler. Must be invoked on protocol's scheduler
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Impl.ProtocolContexts.ReadContextsIntoCookie(JetBrains.Serialization.UnsafeReader)">
            <summary>
            Reads context values from a message, sets current context to them, and returns a cookie to restore previous context
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Impl.ProtocolContexts.WriteContexts(JetBrains.Serialization.UnsafeWriter)">
            <summary>
            Writes the current context values
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Impl.ProtocolContexts.WriteEmptyContexts(JetBrains.Serialization.UnsafeWriter)">
            <summary>
            Writes an empty context
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.RdSecureString">
            <summary>
            This is a temporary stub for proper secure strings in protocol
            Unlike a normal string, this one won't be stored in logs or any other string representations of protocol entities
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.SocketWire.Base.TimeoutMs">
            <summary>
            Timeout for <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)"/>  and for <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)"/>  from socket (to guarantee read_thread termination if <see cref="M:System.Net.Sockets.Socket.Close"/> doesn't
            lead to exception thrown by <see cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)"/>
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.SocketWire.Base.Id">
            <summary>
            For logging
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.SocketWire.Base.myLifetime">
            <summary>
            Lifetime of this wire. If counterpart disconnects, lifetime is not terminate automatically.
            </summary>
        </member>
        <member name="P:JetBrains.Rd.Impl.SocketWire.Base.HeartBeatInterval">
            <summary>
            Ping's interval and not actually detection's timeout.
            Its value must be the same on both sides of connection.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.SocketWire.Base.myCurrentTimeStamp">
            <summary>
            Timestamp of this wire which increases at intervals of <see cref="P:JetBrains.Rd.Impl.SocketWire.Base.HeartBeatInterval"/>
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.SocketWire.Base.myCounterpartTimestamp">
            <summary>
            Actual notion about counterpart's <see cref="F:JetBrains.Rd.Impl.SocketWire.Base.myCurrentTimeStamp"/>
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.SocketWire.Base.myCounterpartNotionTimestamp">
            <summary>
            The latest received counterpart's notion of this wire's <see cref="F:JetBrains.Rd.Impl.SocketWire.Base.myCurrentTimeStamp"/>
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Impl.SocketWire.Server.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.Collections.Viewable.IScheduler,System.Net.Sockets.Socket,System.String)">
            <summary>
            Creates a server wire with an externally-provided socket. By using this constructor, you are not transferring
            ownership of the provided socket to created wire. It is consumer's responsibility to manager socket's lifetime.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.WebSocketSharp.ByteOrder">
            <summary>
            Specifies the byte order.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.ByteOrder.Little">
            <summary>
            Specifies Little-endian.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.ByteOrder.Big">
            <summary>
            Specifies Big-endian.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode">
            <summary>
            Indicates the status code for the WebSocket connection close.
            </summary>
            <remarks>
              <para>
              The values of this enumeration are defined in
              <see href="http://tools.ietf.org/html/rfc6455#section-7.4">
              Section 7.4</see> of RFC 6455.
              </para>
              <para>
              "Reserved value" cannot be sent as a status code in
              closing handshake by an endpoint.
              </para>
            </remarks>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.Normal">
            <summary>
            Equivalent to close status 1000. Indicates normal close.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.Away">
            <summary>
            Equivalent to close status 1001. Indicates that an endpoint is
            going away.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.ProtocolError">
            <summary>
            Equivalent to close status 1002. Indicates that an endpoint is
            terminating the connection due to a protocol error.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.UnsupportedData">
            <summary>
            Equivalent to close status 1003. Indicates that an endpoint is
            terminating the connection because it has received a type of
            data that it cannot accept.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.Undefined">
            <summary>
            Equivalent to close status 1004. Still undefined. A Reserved value.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.NoStatus">
            <summary>
            Equivalent to close status 1005. Indicates that no status code was
            actually present. A Reserved value.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.Abnormal">
            <summary>
            Equivalent to close status 1006. Indicates that the connection was
            closed abnormally. A Reserved value.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.InvalidData">
            <summary>
            Equivalent to close status 1007. Indicates that an endpoint is
            terminating the connection because it has received a message that
            contains data that is not consistent with the type of the message.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.PolicyViolation">
            <summary>
            Equivalent to close status 1008. Indicates that an endpoint is
            terminating the connection because it has received a message that
            violates its policy.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.TooBig">
            <summary>
            Equivalent to close status 1009. Indicates that an endpoint is
            terminating the connection because it has received a message that
            is too big to process.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.MandatoryExtension">
            <summary>
            Equivalent to close status 1010. Indicates that a client is
            terminating the connection because it has expected the server to
            negotiate one or more extension, but the server did not return
            them in the handshake response.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.ServerError">
            <summary>
            Equivalent to close status 1011. Indicates that a server is
            terminating the connection because it has encountered an unexpected
            condition that prevented it from fulfilling the request.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.CloseStatusCode.TlsHandshakeFailure">
            <summary>
            Equivalent to close status 1015. Indicates that the connection was
            closed due to a failure to perform a TLS handshake. A Reserved value.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Impl.WebSocketSharp.Ext.EqualsWith(System.Int32,System.Char,System.Action{System.Int32})">
            <summary>
            Determines whether the specified <see cref="T:System.Int32"/> equals the specified <see cref="T:System.Char"/>,
            and invokes the specified <c>Action&lt;int&gt;</c> delegate at the same time.
            </summary>
            <returns>
            <c>true</c> if <paramref name="value"/> equals <paramref name="c"/>;
            otherwise, <c>false</c>.
            </returns>
            <param name="value">
            An <see cref="T:System.Int32"/> to compare.
            </param>
            <param name="c">
            A <see cref="T:System.Char"/> to compare.
            </param>
            <param name="action">
            An <c>Action&lt;int&gt;</c> delegate that references the method(s) called
            at the same time as comparing. An <see cref="T:System.Int32"/> parameter to pass to
            the method(s) is <paramref name="value"/>.
            </param>
        </member>
        <member name="T:JetBrains.Rd.Impl.WebSocketSharp.Fin">
            <summary>
            Indicates whether a WebSocket frame is the final frame of a message.
            </summary>
            <remarks>
            The values of this enumeration are defined in
            <see href="http://tools.ietf.org/html/rfc6455#section-5.2">Section 5.2</see> of RFC 6455.
            </remarks>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Fin.More">
            <summary>
            Equivalent to numeric value 0. Indicates more frames of a message follow.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Fin.Final">
            <summary>
            Equivalent to numeric value 1. Indicates the final frame of a message.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.WebSocketSharp.HttpVersion">
            <summary>
            Provides the HTTP version numbers.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.HttpVersion.Version10">
            <summary>
            Provides a <see cref="T:System.Version"/> instance for the HTTP/1.0.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.HttpVersion.Version11">
            <summary>
            Provides a <see cref="T:System.Version"/> instance for the HTTP/1.1.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.WebSocketSharp.Mask">
            <summary>
            Indicates whether the payload data of a WebSocket frame is masked.
            </summary>
            <remarks>
            The values of this enumeration are defined in
            <see href="http://tools.ietf.org/html/rfc6455#section-5.2">Section 5.2</see> of RFC 6455.
            </remarks>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Mask.Off">
            <summary>
            Equivalent to numeric value 0. Indicates not masked.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Mask.On">
            <summary>
            Equivalent to numeric value 1. Indicates masked.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.WebSocketSharp.Opcode">
            <summary>
            Indicates the WebSocket frame type.
            </summary>
            <remarks>
            The values of this enumeration are defined in
            <see href="http://tools.ietf.org/html/rfc6455#section-5.2">
            Section 5.2</see> of RFC 6455.
            </remarks>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Opcode.Cont">
            <summary>
            Equivalent to numeric value 0. Indicates continuation frame.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Opcode.Text">
            <summary>
            Equivalent to numeric value 1. Indicates text frame.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Opcode.Binary">
            <summary>
            Equivalent to numeric value 2. Indicates binary frame.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Opcode.Close">
            <summary>
            Equivalent to numeric value 8. Indicates connection close frame.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Opcode.Ping">
            <summary>
            Equivalent to numeric value 9. Indicates ping frame.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Opcode.Pong">
            <summary>
            Equivalent to numeric value 10. Indicates pong frame.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.WebSocketSharp.Rsv">
            <summary>
            Indicates whether each RSV (RSV1, RSV2, and RSV3) of a WebSocket frame is non-zero.
            </summary>
            <remarks>
            The values of this enumeration are defined in
            <see href="http://tools.ietf.org/html/rfc6455#section-5.2">Section 5.2</see> of RFC 6455.
            </remarks>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Rsv.Off">
            <summary>
            Equivalent to numeric value 0. Indicates zero.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.Rsv.On">
            <summary>
            Equivalent to numeric value 1. Indicates non-zero.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Impl.WebSocketSharp.WebSocketException">
            <summary>
            The exception that is thrown when a fatal error occurs in
            the WebSocket communication.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Impl.WebSocketSharp.WebSocketFrameHeader.PayloadMaxLength">
            <summary>
            Represents the allowable max length.
            </summary>
            <remarks>
              <para>
              A <see cref="T:JetBrains.Rd.Impl.WebSocketSharp.WebSocketException"/> will occur if the payload data length is
              greater than the value of this field.
              </para>
              <para>
              If you would like to change the value, you must set it to a value between
              <c>WebSocket.FragmentLength</c> and <c>Int64.MaxValue</c> inclusive.
              </para>
            </remarks>
        </member>
        <member name="M:JetBrains.Rd.ITypesRegistrar.TryRegister(JetBrains.Rd.RdId,JetBrains.Rd.ISerializers)">
            <summary>
            Tries to discovery type with specific <see cref="T:JetBrains.Rd.RdId"/>.
            If it succeeds then should Invoke <see cref="!:ISerializers.Register&lt;T&gt;"/> method on provided serializers.
            </summary>
            <param name="id"></param>
            <param name="serializers"></param>
        </member>
        <member name="P:JetBrains.Rd.IWire.IsStub">
            <summary>
            Used to indicate that the wire implementation is not supposed to be used with the remote counterpart.
            These special wires can be used for local protocols instances to support working with the same models both from
            reactive-distributed way and regular in-process synchronous reactive models.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.WireBase.SendPkg(JetBrains.Serialization.UnsafeWriter.Cookie)">
            <summary>
            Actual send package: len(4 bytes) + id (8 bytes) + payload
            </summary>
            <param name="pkg">Package to transmit</param>
        </member>
        <member name="T:JetBrains.Rd.RdContext`1">
            <summary>
            Describes a context and provides access to value associated with this context.
            The associated value is thread-local and synchronized between send/advise pairs on <see cref="T:JetBrains.Rd.IWire"/>. The associated value will be the same in handler method in <see cref="M:JetBrains.Rd.IWire.Advise(JetBrains.Lifetimes.Lifetime,JetBrains.Rd.Base.IRdWireable)"/> as it was in <see cref="M:JetBrains.Rd.IWire.Send``1(JetBrains.Rd.RdId,``0,System.Action{``0,JetBrains.Serialization.UnsafeWriter})"/>.
            Instances of this class with the same <see cref="!:RdContext.Key"/> will share the associated value.
            Best practice is to declare contexts in toplevel entities in protocol model using <c>Toplevel.context</c>. Manual declaration is also possible.
            </summary>
            <typeparam name="T">The type of value stored by this context</typeparam>
        </member>
        <member name="M:JetBrains.Rd.RdContext`1.#ctor(System.String,System.Boolean,JetBrains.Rd.CtxReadDelegate{`0},JetBrains.Rd.CtxWriteDelegate{`0})">
            <summary>
            
            </summary>
            <param name="key">Textual name of this context. This is used to match this with protocol counterparts</param>
            <param name="isHeavy">Whether or not this context is heavy. A heavy context maintains a value set and interns values. A light context sends values as-is and does not maintain a value set.</param>
            <param name="readDelegate">Serializer to be used with this context.</param>
            <param name="writeDelegate">Serializer to be used with this context.</param>
        </member>
        <member name="P:JetBrains.Rd.RdContext`1.Value">
            <summary>
            Current (thread- or async-local) value for this context
            </summary>
        </member>
        <member name="M:JetBrains.Rd.RdContext`1.PushContext(`0)">
            <summary>
            Pushes current context value to a thread-local stack and sets new value
            </summary>
        </member>
        <member name="M:JetBrains.Rd.RdContext`1.PopContext">
            <summary>
            Restores previous context value from a thread-local stack
            </summary>
        </member>
        <member name="M:JetBrains.Rd.RdId.DefineByFqn(System.Type)">
            <summary>
            Define an RdId by fully-qualified type name.
            You should use it only in case of C#-C# communication.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.Tasks.RpcTimeouts">
            <summary>
            Timeouts for synchronous request by <see cref="M:JetBrains.Rd.Tasks.RdCall`2.Sync(`0,JetBrains.Rd.Tasks.RpcTimeouts)"/>. 
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Tasks.RpcTimeouts.Default">
            <summary>
            This timeout is used by <see cref="M:JetBrains.Rd.Tasks.RdCall`2.Sync(`0,JetBrains.Rd.Tasks.RpcTimeouts)"/> if no timeouts specified and <see cref="F:JetBrains.Rd.Tasks.RpcTimeouts.RespectRpcTimeouts"/> is <c>true</c>.
            If request lasts more than 200 ms from UI Thread it could lead to UI freeze, so <see cref="!:ILog.Warn"/> will be reported after <c>Sync</c> finished.
            If request lasts more than 3000 ms it's considered as hang. <c>Sync</c> request interrupts and <see cref="!:ILog.Error"/> is reported.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Tasks.RpcTimeouts.Maximal">
            <summary>
            This timeout is used by <see cref="M:JetBrains.Rd.Tasks.RdCall`2.Sync(`0,JetBrains.Rd.Tasks.RpcTimeouts)"/> if no timeouts specified and <see cref="F:JetBrains.Rd.Tasks.RpcTimeouts.RespectRpcTimeouts"/> is <c>false</c>.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Tasks.RpcTimeouts.RespectRpcTimeouts">
            <summary>
            Static property used mainly for tests. <c>true</c> by default. If <c>false</c> <see cref="F:JetBrains.Rd.Tasks.RpcTimeouts.Maximal"/> timeouts are used by
            <see cref="M:JetBrains.Rd.Tasks.RdCall`2.Sync(`0,JetBrains.Rd.Tasks.RpcTimeouts)"/> by default.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Tasks.RpcTimeouts.Max(JetBrains.Rd.Tasks.RpcTimeouts,JetBrains.Rd.Tasks.RpcTimeouts)">
            <summary>
            Choose maximal of two timeouts maximizing Warn and Error await time among two.
            </summary>
            <param name="x">First timeouts</param>
            <param name="y">Second timeouts</param>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Rd.Tasks.RpcTimeouts.WarnAwaitTime">
            <summary>
            Time after which <see cref="!:ILog.Warn"/> is reported.
            </summary>
        </member>
        <member name="F:JetBrains.Rd.Tasks.RpcTimeouts.ErrorAwaitTime">
            <summary>
            Time after which <see cref="!:ILog.Error"/> is reported.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Tasks.RpcTimeouts.#ctor(System.TimeSpan,System.TimeSpan)">
            <summary>
            Creates new timeouts
            </summary>
            <param name="warnAwaitTime">Must be more than 0 ms and less or equal than <paramref name="errorAwaitTime"/>.</param>
            <param name="errorAwaitTime">Must be more or equal than <paramref name="warnAwaitTime"/></param>.
        </member>
        <member name="M:JetBrains.Rd.Tasks.RpcTimeouts.GetRpcTimeouts(JetBrains.Rd.Tasks.RpcTimeouts)">
            <summary>
            Returns a mix of optionally provided timeouts and default one.
            </summary>
        </member>
        <member name="M:JetBrains.Rd.Text.Impl.RdTextBuffer.#ctor">
            <summary>
            Slave of the text buffer supports a list of changes that were introduced locally and can be rolled back when master buffer reports incompatible change
            </summary>
        </member>
    </members>
</doc>
